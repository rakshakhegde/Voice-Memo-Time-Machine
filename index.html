<!doctype html>
<html lang="en">

<link rel="icon" type="image/x-icon" href="voice_memo_time_machine.ico">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Voice Memo Time Machine</title>
  <style>
    :root {
      --bg: #0b0f12;
      --card: #0f1620;
      --muted: #8b98a6;
      --accent: #6ee7b7;
      --accent-dark: hsla(156, 40%, 24%, 0.5);
      --danger: #ff6b6b;
      --glass: rgba(255, 255, 255, 0.03);
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: #e6eef6;
      font-family: Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, "Helvetica Neue", Arial;
    }

    .app {
      max-width: 1100px;
      margin: 28px auto;
      padding: 24px;
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 20px;
    }

    .panel {
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), transparent);
      border-radius: 14px;
      padding: 18px;
      box-shadow: 0 6px 30px rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.03);
    }

    h1 {
      margin: 0 0 10px 0;
      font-size: 18px
    }

    .muted {
      color: var(--muted);
      font-size: 13px
    }

    select,
    button {
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: 10px;
      border-radius: 10px;
      color: inherit;
      font-size: 14px
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 12px
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center
    }

    .durations {
      display: flex;
      flex-wrap: wrap;
      gap: 8px
    }

    .dur-btn {
      padding: 8px 12px;
      border-radius: 999px;
      background: var(--glass);
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.02)
    }

    .dur-btn:hover {
      transform: translateY(-2px)
    }

    .status {
      font-size: 12px;
      color: var(--muted)
    }

    .meter {
      height: 10px;
      border-radius: 8px;
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0.02));
      overflow: hidden
    }

    .level {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--accent), #2ad1a3)
    }

    canvas {
      width: 100%;
      height: 120px;
      border-radius: 10px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.01), rgba(255, 255, 255, 0.00));
      display: block
    }

    .right {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .snippet-card {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.015), transparent);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.02)
    }

    .snippet-controls {
      display: flex;
      gap: 10px;
      align-items: center
    }

    .player {
      display: flex;
      flex: 1;
      gap: 12px;
    }

    audio {
      width: 100%;
      border-radius: 8px;
    }

    .download {
      padding: 8px 12px;
      border-radius: 10px;
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.06);
      cursor: pointer
    }

    .small {
      font-size: 13px
    }

    .device-label {
      font-weight: 600
    }

    .hint {
      font-size: 12px;
      color: var(--muted)
    }

    footer {
      color: var(--muted);
      font-size: 12px;
      text-align: center;
      margin-top: 12px
    }

    .warning {
      color: var(--danger);
      font-size: 13px
    }

    @media (max-width:880px) {
      .app {
        grid-template-columns: 1fr;
        padding: 12px
      }
    }

    #liveClock {
      white-space: nowrap;
      font-variant-numeric: tabular-nums;
    }

    /* --- Custom logger styles --- */
    .logger-container {
      background: var(--glass);
      border-radius: 8px;
      padding: 0 10px;
      border: 1px solid rgba(255, 255, 255, 0.02);
    }

    .log-title-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      padding: 6px 2px;
    }

    .log-header {
      font-size: 10px;
      color: #e6eef6;
      margin-left: 2px;
    }

    .arrow {
      font-size: 8px;
      transition: transform 0.2s;
      margin-right: 5px;
    }

    .arrow.collapsed {
      transform: rotate(-90deg);
    }

    .log-content {
      overflow-y: auto;
      max-height: 200px;
      transition: all 0.3s ease-out;
      border-top: 1px solid rgba(255, 255, 255, 0.05);
      padding: 8px 0;
    }

    .log-content.collapsed {
      max-height: 0;
      padding: 0;
      overflow: hidden;
      border-top: none;
    }

    #logger {
      font-size: 11px;
      color: var(--muted);
      white-space: nowrap;
      width: 200px;
    }

    .small-btn {
      padding: 2px 6px;
      font-size: 8px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.08);
      cursor: pointer;
      margin-left: 10px;
    }

    .log-control {
      display: flex;
      align-items: center;
    }

    #uptimeDiv {
      display: flex;
      align-items: center;
      flex-wrap: nowrap;
    }

    #uptimeClock {
      font-variant-numeric: tabular-nums;
      margin-left: 4px;
    }

    #logContent {
      /* This is crucial for positioning the 'Copied!' message absolutely inside it */
      position: relative;
    }

    /* CSS for the dynamically created "Copied!" message */
    #copy-feedback {
      position: absolute;
      top: 50%;
      /* Start at 50% from the top */
      left: 50%;
      /* Start at 50% from the left */
      transform: translate(-50%, -50%);
      /* Shift back by half its width/height to perfectly center it */

      /* Styling */
      background-color: rgba(0, 0, 0, 0.75);
      /* Dark, semi-transparent background */
      color: white;
      padding: 8px 15px;
      border-radius: 5px;
      font-size: 0.8em;
      opacity: 0;
      pointer-events: none;
      /* Allows clicks to pass through to the element beneath */

      /* Fade out transition */
      transition: opacity 0.5s ease-in-out;
    }

    #copy-feedback.show {
      opacity: 1;
    }

    :focus {
      outline: 1px solid var(--accent-dark);
      outline-offset: 2px;
      outline-width: 2px;
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="panel">
      <h1 style="cursor: pointer;" onclick="window.open('voice_memo_time_machine.jpg', '_blank')">
        <img src="voice_memo_time_machine.ico" style="height: 1.2em; vertical-align: middle; margin-right: 8px;"
          alt="favicon of voice memo time machine">
        <span style="vertical-align: middle; cursor: pointer;">Rolling Hour Recorder</span>
      </h1>
      <div class="muted">Records continuously (rolling 1 hour). Extract snippets while recording.</div>
      <div style="height:14px"></div>

      <div class="controls">
        <div>
          <div style="display:flex;justify-content:space-between;align-items:end;">
            <div>
              <div class="device-label" id="deviceLabel">Microphone: â€”</div>
              <div class="hint" style="margin-top:0px;">Choose input microphone (default: Macbook Pro Microphone)</div>
            </div>
            <div style="text-align:right">
              <div class="status" id="recStatus">Status: initializingâ€¦</div>
              <div class="status" id="srDisplay" style="margin-top:2px;">Sample rate: â€”</div>
            </div>
          </div>
          <div style="height:10px"></div>
          <div class="row">
            <select id="deviceSelect"></select>
            <button id="restartBtn">Restart</button>
          </div>
        </div>

        <div>
          <div>
            <div id="uptimeDiv" class="muted small" style="float:right;">
              <div>Uptime: </div>
              <div id="uptimeClock">00:00</div>
            </div>
            <div class="muted small">Live waveform (past 30s)</div>
          </div>
          <canvas id="liveWave" width="800" height="120" style="margin-top:4px;"></canvas>
          <div style="height:8px"></div>
          <div class="meter">
            <div id="level" class="level"></div>
          </div>
        </div>

        <div>
          <div class="muted small">Extract snippet durations</div>
          <div class="durations" id="durations">
            <button class="dur-btn" data-sec="10">10s</button>
            <button class="dur-btn" data-sec="30">30s</button>
            <button class="dur-btn" data-sec="60">1m</button>
            <button class="dur-btn" data-sec="120">2m</button>
            <button class="dur-btn" data-sec="300">5m</button>
            <button class="dur-btn" data-sec="600">10m</button>
            <button class="dur-btn" data-sec="1800">30m</button>
            <button class="dur-btn" data-sec="3600">1h</button>
          </div>
        </div>

        <div>
          <div class="muted small">Storage</div>
          <div class="hint">Buffer: last 1 hour of raw audio (16-bit PCM) â€” memory usage depends on mic sample rate.
          </div>
          <div style="height:8px"></div>
          <div id="memoryInfo" class="muted small">Est. buffer bytes: â€”</div>

          <div style="height:8px;"></div>
          <div class="logger-container" id="loggerContainer">
            <div class="log-title-row">
              <div class="log-control">
                <span class="arrow collapsed" id="logArrow">â–¼</span>
                <span class="log-header">Logs</span>
              </div>
              <button id="clearLogBtn" class="small-btn">Clear</button>
            </div>
            <div id="logContent" class="log-content collapsed">
              <div id="logger"></div>
              <div id="copy-feedback">Copied!</div>
            </div>
          </div>
        </div>
      </div>
      <footer style="cursor: pointer;"
        onclick="window.open('https\://github.com/rakshakhegde/Voice-Memo-Time-Machine', '_blank')">Built â€” Rolling
        recorder (client-only). No external servers.</footer>
    </div>

    <div class="right">
      <div class="panel">
        <div>
          <div style="overflow: auto;">
            <div id="liveClock" class="muted small" style="float:right; margin-top:2px;">â€”</div>
            <div style="font-weight:700;">Snippets</div>
          </div>
          <div class="muted small" style="margin-top:4px;">Choose a duration, or click any existing snippet to inspect
          </div>
        </div>

        <div id="no-snippet-msg" class="muted small" style="margin-top:8px;">No snippet selected yet. Click a duration
          to extract.</div>
        <div id="snippetsArea" style="margin-top:12px;display:flex;flex-direction:column;gap:12px">
        </div>
      </div>

      <div class="panel">
        <div class="muted small">Notes & tips</div>
        <ul class="muted small">
          <li>Allow microphone access when prompted. The app will start recording automatically after permission.</li>
          <li>Snippets are generated client-side as WAV files and downloadable.</li>
          <li>If the browser prevents autoplaying audio or starting recording on load, click "Restart" to initialize
            after granting permission.</li>
        </ul>
        <div style="height:10px"></div>
        <div id="warnBox" class="warning" style="display:none"></div>
      </div>
    </div>
  </div>

  <script>
    /*
     Rolling Hour Recorder with AudioWorklet (single-file)
     - circular buffer: Int16Array storing mono PCM for last 1 hour
     - inline AudioWorklet module created from a Blob
     - live waveform (30s) and snippet extraction to WAV
    */

    (async function () {
      const MAX_SNIPPETS = 10;
      // UI references
      const deviceSelect = document.getElementById('deviceSelect');
      const deviceLabel = document.getElementById('deviceLabel');
      const srDisplay = document.getElementById('srDisplay');
      const recStatus = document.getElementById('recStatus');
      const liveWave = document.getElementById('liveWave');
      const liveCtx = liveWave.getContext('2d');
      const levelBar = document.getElementById('level');
      const durationsDiv = document.getElementById('durations');
      const snippetsArea = document.getElementById('snippetsArea');
      const memoryInfo = document.getElementById('memoryInfo');
      const restartBtn = document.getElementById('restartBtn');
      const liveClock = document.getElementById('liveClock');
      const warnBox = document.getElementById('warnBox');
      const uptimeClock = document.getElementById('uptimeClock');

      // Logger UI references (UPDATED)
      const loggerContainer = document.getElementById('loggerContainer');
      const logTitleRow = loggerContainer.querySelector('.log-title-row');
      const logContent = document.getElementById('logContent');
      const loggerDiv = document.getElementById('logger');
      const clearLogBtn = document.getElementById('clearLogBtn');
      const logArrow = document.getElementById('logArrow');
      const copyFeedback = document.getElementById('copy-feedback');

      const noSnippetMsg = document.getElementById('no-snippet-msg');


      // Click to clear logs (UPDATED: now on clear button)
      clearLogBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent container collapse/expand
        loggerDiv.innerHTML = '';
      });

      // Collapse/Expand functionality
      logTitleRow.addEventListener('click', () => {
        const isCollapsed = logContent.classList.contains('collapsed');
        if (isCollapsed) {
          logContent.classList.remove('collapsed');
          logArrow.classList.remove('collapsed');
        } else {
          logContent.classList.add('collapsed');
          logArrow.classList.add('collapsed');
        }
      });


      // config
      const MAX_SECONDS = 3600; // 1 hour
      const LIVE_SECONDS = 30;  // live waveform window
      let audioContext = null;
      let micStream = null;
      let sourceNode = null;
      let sampleRate = 48000;
      let buffer = null; // Int16Array circular buffer
      let bufferLength = 0;
      let writeIndex = 0;
      let totalSamplesRecorded = 0;
      let recording = false;
      let channelCount = 1;
      let selectedDeviceId = null;
      let deviceList = [];
      let reuseBuffer = null;

      let lastUsedMicLabel = localStorage.getItem('lastUsedMicLabel') || 'MacBook Pro Microphone';
      let lastUsedDeviceId = localStorage.getItem('lastUsedDeviceId');

      // Inline AudioWorklet code
      const workletCode = `
        class RecorderProcessor extends AudioWorkletProcessor {
          constructor() {
            super();
            // Buffer to hold the converted Int16 data for posting back
            this.int16Buffer = new Int16Array(128); 
          }
          
          process(inputs) {
            const input = inputs[0];
            if (input && input.length > 0) {
              const ch0 = input[0]; // This is the input Float32Array (read-only reference)
              
              // Convert floats from the input channel (ch0) to int16
              // Calculate RMS while converting
              let sumOfSquares = 0;

              for (let i = 0; i < ch0.length; i++) {
                // Clamp the float value between -1 and 1
                const s = Math.max(-1, Math.min(1, ch0[i]));
                
                // Convert to Int16
                const int16 = (s < 0 ? s * 32768 : s * 32767) | 0;
                
                this.int16Buffer[i] = int16;

                sumOfSquares += s * s;
              }

              const rms = Math.sqrt(sumOfSquares / ch0.length);

              this.port.postMessage({
                  intSamples: this.int16Buffer,
                  rms: rms
              });
            }
            return true;
          }
        }
        registerProcessor('recorder-processor', RecorderProcessor);
      `;
      const workletBlob = new Blob([workletCode], { type: 'application/javascript' });
      const workletURL = URL.createObjectURL(workletBlob);

      let recorderNode;

      // Start initialization
      log('await initAndStart start');
      await initAndStart();
      log('await initAndStart done');

      // UI wiring
      log('restart UI wiring');
      restartBtn.onclick = async () => { await restart(); };
      deviceSelect.onchange = async () => { selectedDeviceId = deviceSelect.value; await restart(); };
      durationsDiv.addEventListener('click', async ev => {
        const btn = ev.target.closest('.dur-btn');
        if (!btn) return;
        const seconds = Number(btn.dataset.sec);
        await createSnippet(seconds);
      });
      durationsDiv.addEventListener('keydown', ev => {
        if (ev.code === 'Space') {
          ev.preventDefault();

          const firstAudio = snippetsArea.querySelector('audio');
          if (firstAudio) {
            firstAudio.play();
            firstAudio.focus();
          }
        }
      });

      // ---------- Initialization ----------
      async function initAndStart() {
        log('initAndStart');
        try {
          await startRecordingWithWorklet();
          recStatus.textContent = 'Status: Recording';
          recording = true;
        } catch (err) {
          console.error('init error', err);
          recStatus.textContent = 'Status: âŒ Stopped';
          warnBox.style.display = 'block';
          warnBox.textContent = 'Microphone access required â€” click "Restart" and allow microphone. Some browsers prevent auto-start on load.';
        }
        requestAnimationFrame(drawLiveWave);
        setInterval(() => {
          liveClock.textContent = new Date().toLocaleString();
          uptimeClock.textContent = formatUptime(totalSamplesRecorded / sampleRate);
        }, 1000);
        setupLogger();
      }

      async function restart() {
        log('restart');
        await stopRecording();
        await startRecordingWithWorklet();
      }

      function allocateCircularBuffer() {
        log('allocateCircularBuffer');
        if (sampleRate * MAX_SECONDS == bufferLength) {
          logToDiv('Reusing existing circular buffer');
          return;
        }
        bufferLength = sampleRate * MAX_SECONDS;
        buffer = new Int16Array(bufferLength);
        writeIndex = 0;
        totalSamplesRecorded = 0;
        const memoryBytesEstimate = bufferLength * 2;
        memoryInfo.textContent = 'Est. buffer bytes: ' + formatBytes(memoryBytesEstimate) + ' (' + bufferLength + ' samples)';
      }

      function formatBytes(n) {
        if (n > 1e9) return (n / 1e9).toFixed(2) + ' GB';
        if (n > 1e6) return (n / 1e6).toFixed(2) + ' MB';
        if (n > 1e3) return (n / 1e3).toFixed(2) + ' KB';
        return n + ' bytes';
      }

      async function startRecordingWithWorklet() {
        log("ðŸŽ™ï¸ unified startRecordingWithWorklet");

        // 1ï¸âƒ£ Determine which mic to use
        const savedId = selectedDeviceId || localStorage.getItem("lastUsedDeviceId");
        const savedLabel = localStorage.getItem("lastUsedMicLabel");

        // 2ï¸âƒ£ Step 1: request temp stream (to unlock labels)
        let tempStream = null;
        try {
          if (savedId) {
            tempStream = await navigator.mediaDevices.getUserMedia({
              audio: { deviceId: { exact: savedId } },
            });
          } else {
            tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          }
        } catch (err) {
          logToDiv("âš ï¸ Could not open saved device, falling back to default mic:", err);
          tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        }

        // 3ï¸âƒ£ Step 2: enumerate devices (labels now available)
        const devices = (await navigator.mediaDevices.enumerateDevices())
          .filter((d) => d.kind === "audioinput");

        // 4ï¸âƒ£ Step 3: pick the correct device using hybrid logic
        let chosenDevice =
          devices.find((d) => d.deviceId === savedId) ||
          devices.find((d) => d.label === savedLabel) ||
          devices.find((d) => d.label == 'MacBook Pro Microphone') ||
          devices[0];

        if (!chosenDevice) {
          recStatus.textContent = 'âŒ No input devices available.';
          return;
        }

        logToDiv("ðŸŽ§ Chosen mic:", chosenDevice.label, chosenDevice.deviceId);

        // 5ï¸âƒ£ Step 4: update dropdown UI
        deviceSelect.innerHTML = "";
        devices.forEach((d) => {
          const opt = document.createElement("option");
          opt.value = d.deviceId;
          opt.textContent = d.label || `Microphone ${deviceSelect.length + 1}`;
          deviceSelect.appendChild(opt);
        });
        deviceSelect.value = chosenDevice.deviceId;
        deviceLabel.textContent = "Microphone: " + (chosenDevice.label || "Unknown");

        // 6ï¸âƒ£ Step 5: update persistent info
        localStorage.setItem("lastUsedDeviceId", chosenDevice.deviceId);
        localStorage.setItem("lastUsedMicLabel", chosenDevice.label || "");
        selectedDeviceId = chosenDevice.deviceId;

        // 7ï¸âƒ£ Step 6: reuse or reopen mic stream
        const tempTrack = tempStream.getAudioTracks()[0];
        const tempDeviceId = tempTrack.getSettings().deviceId;

        if (tempDeviceId === chosenDevice.deviceId) {
          logToDiv("â™»ï¸ Reusing existing tempStream for chosen mic:", chosenDevice.label);
          micStream = tempStream;
        } else {
          logToDiv("ðŸ”„ Opening new stream for chosen mic:", chosenDevice.label);
          tempStream.getTracks().forEach((t) => t.stop());
          micStream = await navigator.mediaDevices.getUserMedia({
            audio: { deviceId: { exact: chosenDevice.deviceId } },
          });
        }

        if (micStream) {
          const track = micStream.getAudioTracks()[0];
          if (track) {
            const settings = track.getSettings();
            logToDiv("ðŸŽ¤ Mic stream settings:", settings);

            track.onended = () => {
              logToDiv("ðŸ”´ Track Ended.", {
                id: track.id,
                kind: track.kind
              });
              restart();
            }
          }
        }

        // 8ï¸âƒ£ Step 7: setup AudioContext and worklet
        if (!audioContext || audioContext.state === 'closed') {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          sampleRate = audioContext.sampleRate;
          srDisplay.textContent = 'Sample rate: ' + sampleRate + ' Hz';
          allocateCircularBuffer();
          audioContext.onstatechange = () => {
            logToDiv(`ðŸŽ§ AudioContext state: ${audioContext.state}`);
          };
        } else if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }

        if (!audioContext.workletModuleLoaded) {
          await audioContext.audioWorklet.addModule(workletURL);
          audioContext.workletModuleLoaded = true;

          // Optional: only revoke if you re-create workletURL each time
          // URL.revokeObjectURL(workletURL);
        }

        recorderNode?.disconnect();
        recorderNode = new AudioWorkletNode(audioContext, "recorder-processor");

        recorderNode.port.onmessage = (event) => {
          writeToCircularBuffer(event.data.intSamples);
          updateLevelMeter(event.data.rms);
        };
        recorderNode.onprocessorerror = (err) => {
          logToDiv('âŒ Recorder processor error:', err);
        };

        // Connect mic â†’ worklet â†’ destination (optional for monitoring)
        try { sourceNode?.disconnect(); } catch (e) {
          logToDiv('sourceNode disconnect error', e);
        }
        sourceNode = audioContext.createMediaStreamSource(micStream);
        sourceNode.connect(recorderNode);
        // recorderNode.connect(audioContext.destination); // uncomment to hear yourself
        // connect a gain of 0 to destination if some browsers require a connection to destination
        // but we avoid audible output by not connecting workletNode to destination.
        recStatus.textContent = 'Status: Recording';
        recording = true;

        logToDiv("ðŸŽ¬ Recording started with:", chosenDevice.label);
      }

      function stopRecording() {
        log('stopRecording');
        if (micStream) {
          micStream.getTracks().forEach(t => t.stop());
          micStream = null;
        }
        if (sourceNode) {
          try { sourceNode.disconnect(); } catch (e) {
            log('sourceNode disconnect error', e);
          }
          sourceNode = null;
        }
        recStatus.textContent = 'Status: âŒ Stopped';
        recording = false;
      }

      function writeToCircularBuffer(intSamples) {
        const samplesLength = intSamples.length;
        const segmentLength = Math.min(samplesLength, bufferLength - writeIndex);
        buffer.set(intSamples.subarray(0, segmentLength), writeIndex);
        buffer.set(intSamples.subarray(segmentLength, samplesLength), 0);
        writeIndex += samplesLength;
        if (writeIndex >= bufferLength) writeIndex -= bufferLength;
        totalSamplesRecorded += samplesLength;
      }

      function updateLevelMeter(rms) {
        levelBar.style.width = Math.min(1, rms * 4) * 100 + '%';
      }

      // ---------- Snippet extraction ----------
      function extractLastNSeconds(seconds) {
        log('extractLastNSeconds');
        if (!buffer) return new Int16Array(0);

        const samplesNeeded = Math.min(Math.floor(sampleRate * seconds), bufferLength);
        const result = new Int16Array(samplesNeeded);
        let start = writeIndex - samplesNeeded;
        if (start < 0) start += bufferLength;
        if (start + samplesNeeded <= bufferLength) {
          result.set(buffer.subarray(start, start + samplesNeeded), 0);
        } else {
          const firstPart = bufferLength - start;
          result.set(buffer.subarray(start, start + firstPart), 0);
          result.set(buffer.subarray(0, samplesNeeded - firstPart), firstPart);
        }
        return result;
      }

      function extractLastNSecondsForLive() {
        //log('extractLastNSecondsForLive');
        if (!buffer) return new Int16Array(0);
        const requiredSize = LIVE_SECONDS * sampleRate;
        const availableSamples = Math.min(requiredSize, bufferLength);
        // reuse an Int16Array pool (store raw int16 PCM)
        if (!reuseBuffer || reuseBuffer.length !== availableSamples) {
          reuseBuffer = new Int16Array(availableSamples);
        }
        const result = reuseBuffer;
        const total = availableSamples;
        let start = writeIndex - total;
        if (start < 0) start += bufferLength;
        if (start + total <= bufferLength) {
          // contiguous
          result.set(buffer.subarray(start, start + total), 0);
        } else {
          // wrapped
          const firstPart = bufferLength - start;
          result.set(buffer.subarray(start, start + firstPart), 0);
          result.set(buffer.subarray(0, total - firstPart), firstPart);
        }
        return result.subarray(0, total);
      }

      function makeWavBlob(intSamples) {
        const numChannels = 1;
        const sampleRateLocal = sampleRate;
        const bufferLen = intSamples.length * 2; // 2 bytes per sample
        const wavBuffer = new ArrayBuffer(44 + bufferLen);
        const view = new DataView(wavBuffer);

        function writeString(dataview, offset, str) {
          for (let i = 0; i < str.length; i++) dataview.setUint8(offset + i, str.charCodeAt(i));
        }

        // Write WAV header
        writeString(view, 0, 'RIFF');
        view.setUint32(4, 36 + bufferLen, true);
        writeString(view, 8, 'WAVE');
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRateLocal, true);
        view.setUint32(28, sampleRateLocal * numChannels * 2, true);
        view.setUint16(32, numChannels * 2, true);
        view.setUint16(34, 16, true);
        writeString(view, 36, 'data');
        view.setUint32(40, bufferLen, true);

        // Write PCM data
        let offset = 44;
        for (let i = 0; i < intSamples.length; i++, offset += 2) {
          view.setInt16(offset, intSamples[i], true);
        }

        return new Blob([view], { type: 'audio/wav' });
      }

      async function createSnippet(seconds) {
        log('createSnippet');
        recStatus.textContent = 'Status: Creating snippetâ€¦';

        const totalRecordedSec = totalSamplesRecorded / sampleRate;
        const actualSeconds = Math.min(seconds, totalRecordedSec);
        if (actualSeconds <= 0) {
          alert('No audio available yet. Wait a few seconds and try again.');
          recStatus.textContent = 'Status: Recording';
          return;
        }

        const intSamples = extractLastNSeconds(actualSeconds);
        const blob = makeWavBlob(intSamples);
        const url = URL.createObjectURL(blob);
        const snippetTime = new Date();

        if (snippetsArea.children.length == 0) noSnippetMsg.style.display = 'none';

        while (snippetsArea.children.length >= MAX_SNIPPETS) {
          snippetsArea.removeChild(snippetsArea.lastChild);
        }

        const card = document.createElement('div');
        card.className = 'snippet-card';
        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.style.alignItems = 'center';

        // --- Start Title/Edit Enhancements (Updated) ---

        const titleContainer = document.createElement('div');
        titleContainer.style.display = 'flex';
        titleContainer.style.alignItems = 'center';
        titleContainer.style.gap = '6px'; // Adjusted gap
        titleContainer.style.cursor = 'pointer';

        const titleDiv = document.createElement('div');
        titleDiv.style.fontWeight = '700';
        titleDiv.style.cursor = 'pointer'; // Indicate clickability
        const snippetDuration = intSamples.length / sampleRate;
        titleDiv.textContent = `${formatSeconds(snippetDuration)}`;

        const editIcon = document.createElement('span');
        // Using a standard grey pencil Unicode character
        editIcon.textContent = '\u270E';
        editIcon.title = 'Edit Title';
        editIcon.style.cursor = 'pointer';
        editIcon.style.padding = '5px'; // Increased padding for a larger hit area
        editIcon.style.borderRadius = '50%';
        editIcon.style.transition = 'background-color 0.2s, color 0.2s';
        editIcon.style.color = '#555'; // Dark Grey color for the icon
        editIcon.style.lineHeight = '1'; // Ensures the icon is centered vertically
        editIcon.style.transform = 'scaleX(-1)';

        // Hover effect for the pencil icon (Dark Round Background)
        editIcon.onmouseover = () => {
          editIcon.style.backgroundColor = 'rgba(0, 0, 0, 0.2)'; // Semi-transparent dark round background
        };
        editIcon.onmouseout = () => {
          editIcon.style.backgroundColor = 'transparent';
        };

        // Make the title editable when the icon is clicked
        editIcon.onclick = () => {
          makeTitleEditable(titleDiv, editIcon);
        };

        // Allow editing when the title text itself is clicked
        titleDiv.onclick = () => {
          makeTitleEditable(titleDiv, editIcon);
        };

        titleContainer.onclick = () => {
          makeTitleEditable(titleDiv, editIcon);
        };

        titleContainer.appendChild(titleDiv);
        titleContainer.appendChild(editIcon);
        header.appendChild(titleContainer);

        // --- End Title/Edit Enhancements ---


        const dateDiv = document.createElement('div');
        dateDiv.style.display = 'flex';
        dateDiv.style.alignItems = 'center';
        dateDiv.style.gap = '6px';

        const dateText = document.createElement('span');
        dateText.className = 'muted small';
        dateText.textContent = snippetTime.toLocaleString();
        dateText.style.whiteSpace = 'nowrap';
        dateDiv.appendChild(dateText);

        const removeBtn = document.createElement('button');
        removeBtn.textContent = 'Ã—';
        removeBtn.style.background = 'transparent';
        removeBtn.style.border = 'none';
        removeBtn.style.color = 'var(--danger)';
        removeBtn.style.cursor = 'pointer';
        removeBtn.style.fontSize = '14px';
        removeBtn.onclick = () => {
          snippetsArea.removeChild(card);
          if (snippetsArea.children.length === 0) noSnippetMsg.style.display = 'block';
        };
        dateDiv.appendChild(removeBtn);

        header.appendChild(dateDiv);
        card.appendChild(header);


        // waveform canvas (HiDPI)
        const canvas = document.createElement('canvas');
        canvas.style.width = '100%';
        canvas.style.height = '120px';
        const dpr = window.devicePixelRatio || 1;
        const parentWidth = Math.max(800, snippetsArea.clientWidth || 800);
        canvas.width = Math.round(parentWidth * dpr);
        canvas.height = Math.round(120 * dpr);
        card.appendChild(canvas);
        drawSnippetWaveform(intSamples, canvas);

        // audio controls + download
        const controls = document.createElement('div');
        controls.className = 'snippet-controls';
        const playerWrap = document.createElement('div');
        playerWrap.className = 'player';

        const audio = document.createElement('audio');
        audio.controls = true;
        audio.src = url;
        audio.preload = 'auto';
        playerWrap.appendChild(audio);
        card.audio = audio;

        const dl = document.createElement('button');
        dl.className = 'download';
        dl.textContent = 'Download';
        dl.onclick = () => {
          const stamp = snippetTime;
          // Use the current title for the filename, sanitized
          const currentTitle = titleDiv.textContent.replace(/[^a-z0-9]/gi, '_').toLowerCase();
          const timeStr = stamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true })
            .replaceAll(':', '-').replace(/\s/g, '');
          const dateStr = stamp.toLocaleDateString([], { month: 'numeric', day: 'numeric', year: 'numeric' })
            .replaceAll('/', '-');
          const name = `${currentTitle} ${timeStr} ${dateStr} audio-timemachine.wav`;
          const a = document.createElement('a');
          a.href = url;
          a.download = name;
          a.click();
        };

        controls.appendChild(playerWrap);
        controls.appendChild(dl);
        card.appendChild(controls);
        snippetsArea.prepend(card);

        audio.addEventListener('play', () => {
          for (const p of snippetsArea.children) {
            if (p.audio && p.audio !== audio) {
              p.audio.pause();
            }
          }
        });

        playerSeekUI(audio, canvas, intSamples);

        recStatus.textContent = 'Status: Recording';
      }

      // ðŸŽ¶ Function to handle the title editing ðŸŽ¶
      function makeTitleEditable(titleDiv, editIcon) {
        // Prevent editing if already an input field
        if (titleDiv.querySelector('input')) return;

        const currentText = titleDiv.textContent;

        // 1. Create the input field
        const input = document.createElement('input');
        input.type = 'text';
        input.value = currentText;
        input.style.fontWeight = '700'; // Keep the bold style
        input.style.border = '1px solid #aaa'; // Subtle grey border
        input.style.borderRadius = '4px';
        input.style.padding = '2px 4px';
        input.style.fontSize = 'inherit'; // Inherit font size
        input.style.fontFamily = 'inherit'; // Inherit font family
        input.style.color = 'inherit';
        input.style.backgroundColor = 'transparent';
        input.style.minWidth = '100px'; // Ensure input is wide enough

        // 2. Replace the div content with the input
        titleDiv.textContent = '';
        titleDiv.appendChild(input);
        input.focus();
        input.select();

        // Hide the edit icon temporarily
        editIcon.style.visibility = 'hidden';

        const validInput = () => input.value.trim() || currentText;

        // Function to save the changes
        const saveChanges = (newText) => {
          titleDiv.textContent = newText;
          titleDiv.onclick = () => { makeTitleEditable(titleDiv, editIcon); }; // Restore click handler
          editIcon.style.visibility = 'visible'; // Show icon again
          editIcon.style.backgroundColor = 'transparent'; // Reset background if blur fires while hovering
        };

        // 3. Handle 'Enter' key press (or 'Go/Ok' on mobile keyboards)
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            saveChanges(validInput());
          } else if (e.key === 'Escape') {
            e.preventDefault();
            saveChanges(currentText);
          }
        });

        // 4. Handle loss of focus (blur)
        input.addEventListener('blur', () => saveChanges(validInput()));

        // Remove the direct click-to-edit handler from the div while editing
        titleDiv.onclick = null;
      }

      // show playback progress overlay on snippet waveform
      function playerSeekUI(audio, canvasEl, intSamples) {
        const ctx = canvasEl.getContext('2d');
        const w = canvasEl.width;
        const h = canvasEl.height;
        function drawProgress() {
          drawSnippetWaveform(intSamples, canvasEl);
          const pct = audio.duration ? (audio.currentTime / audio.duration) : 0;
          ctx.fillStyle = 'rgba(100,255,200,0.08)';
          ctx.fillRect(0, 0, Math.max(2, pct * w), h);
          ctx.fillStyle = 'rgba(255,255,255,0.08)';
          ctx.fillRect(Math.max(0, pct * w - 1), 0, 2, h);
        }
        audio.addEventListener('timeupdate', drawProgress);
        canvasEl.addEventListener('click', (ev) => {
          const rect = canvasEl.getBoundingClientRect();
          const x = ev.clientX - rect.left;
          let percent = x / rect.width;
          if (percent <= 0.03) percent = 0;
          if (audio.duration) audio.currentTime = percent * audio.duration;
          audio.play();
          audio.focus();
          drawProgress();
        });
      }

      // waveform drawing for canvas (handles HiDPI canvas sizes)
      function drawSnippetWaveform(intSamples, canvasEl) {
        const ctx = canvasEl.getContext('2d');
        const w = canvasEl.width;
        const h = canvasEl.height;

        // Clear the canvas
        ctx.clearRect(0, 0, w, h);

        // Background gradient
        const g = ctx.createLinearGradient(0, 0, 0, h);
        g.addColorStop(0, 'rgba(255,255,255,0.01)');
        g.addColorStop(1, 'rgba(255,255,255,0.00)');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, w, h);

        // Draw the waveform
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(110,231,183,0.95)';
        ctx.beginPath();

        const pixelWidth = w; // Number of vertical lines to draw
        const step = Math.max(1, Math.ceil(intSamples.length / pixelWidth)); // Samples per pixel column

        for (let i = 0; i < pixelWidth; i++) {
          const start = i * step;
          let min = 32767, max = -32768; // Int16 range

          // Find min and max values for the current column
          for (let j = 0; j < step && (start + j) < intSamples.length; j++) {
            const sample = intSamples[start + j];
            if (sample < min) min = sample;
            if (sample > max) max = sample;
          }

          // Scale min and max to canvas height
          const y1 = ((1 - (min / 32768)) / 2) * h;
          const y2 = ((1 - (max / 32768)) / 2) * h;

          // Draw the line for this column
          ctx.moveTo(i, y1);
          ctx.lineTo(i, y2);
        }

        ctx.stroke();
      }

      // live waveform draw loop
      let lastDraw = 0;
      function drawLiveWave() {
        const now = performance.now();
        if (now - lastDraw < 200) { requestAnimationFrame(drawLiveWave); return; }
        lastDraw = now;

        const canvas = liveWave;
        const ctx = liveCtx;
        const dpr = devicePixelRatio || 1;
        const wCss = canvas.clientWidth;
        const hCss = canvas.clientHeight;
        const w = Math.round(wCss * dpr);
        const h = Math.round(hCss * dpr);
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w;
          canvas.height = h;
        }

        ctx.clearRect(0, 0, w, h);
        ctx.save();
        ctx.scale(dpr, dpr);
        ctx.lineWidth = 1.2;
        ctx.strokeStyle = 'rgba(110,231,183,0.95)';
        ctx.beginPath();

        // extract returns Int16Array now (raw PCM). compute min/max in int domain then scale once.
        const samples = extractLastNSecondsForLive();
        if (samples.length > 0) {
          const step = Math.max(1, Math.floor(samples.length / wCss));
          for (let x = 0; x < wCss; x++) {
            const start = x * step;
            let minInt = 32767, maxInt = -32768;
            for (let k = 0; k < step && (start + k) < samples.length; k++) {
              const vInt = samples[start + k];
              if (vInt < minInt) minInt = vInt;
              if (vInt > maxInt) maxInt = vInt;
            }
            // scale to [-1,1]
            const min = minInt / 32768;
            const max = maxInt / 32768;
            const y1 = (1 - (min + 1) / 2) * hCss;
            const y2 = (1 - (max + 1) / 2) * hCss;
            ctx.moveTo(x, y1);
            ctx.lineTo(x, y2);
          }
          ctx.stroke();
        } else {
          ctx.fillStyle = 'rgba(255,255,255,0.03)';
          ctx.font = '12px system-ui';
          ctx.fillText('waiting for audioâ€¦', 12, 18);
        }

        ctx.restore();
        requestAnimationFrame(drawLiveWave);
      }

      function formatSeconds(s) {
        s = Math.trunc(s);
        const h = Math.floor(s / 3600);
        const m = Math.floor((s % 3600) / 60);
        const sec = s % 60;

        if (h > 0) {
          return `${h}h${m ? m + 'm' : ''}${sec ? sec + 's' : ''}`;
        } else if (m > 0) {
          return `${m}m${sec ? sec + 's' : ''}`;
        } else {
          return `${sec}s`;
        }
      }

      /**
       * Formats a duration given in seconds into a human-readable string.
       * The format adjusts based on the total duration:
       * - < 1 hour: MM:SS (e.g., 03:05)
       * - < 1 day: H:MM:SS (e.g., 1:23:05)
       * - >= 1 day: Xd H:MM:SS (e.g., 1d 2:42:32)
       *
       * @param {number} totalSeconds The total duration in seconds.
       * @returns {string} The formatted duration string.
       */
      function formatUptime(totalSeconds) {
        // Ensure the input is a non-negative integer
        let seconds = Math.max(0, Math.floor(totalSeconds));

        // Helper to pad numbers with a leading zero (always pads to 2 digits)
        const pad = (num) => String(num).padStart(2, '0');

        // --- Calculate D, H, M, S components ---

        const secondsPerDay = 86400; // 24 * 60 * 60
        const secondsPerHour = 3600; // 60 * 60

        const days = Math.floor(seconds / secondsPerDay);
        seconds %= secondsPerDay;

        const hours = Math.floor(seconds / secondsPerHour);
        seconds %= secondsPerHour;

        const minutes = Math.floor(seconds / 60);
        seconds %= 60;

        // --- Format the components based on duration magnitude ---

        // If duration is less than 1 hour (M:SS or MM:SS)
        if (days === 0 && hours === 0) {
          // Use the requested padded minutes format (MM:SS) for clarity below 1 hour.
          return `${pad(minutes)}:${pad(seconds)}`;
        }

        // If duration is 1 hour or more, but less than 1 day (H:MM:SS)
        if (days === 0) {
          // Hours are not padded, but minutes and seconds are.
          return `${hours}:${pad(minutes)}:${pad(seconds)}`;
        }

        // If duration is 1 day or more (Xd H:MM:SS)
        // Days are not padded, but hours, minutes, and seconds are.
        return `${days}d ${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
      }

      function setupLogger() {
        loggerDiv.addEventListener('click', () => {
          const textToCopy = loggerDiv.textContent || loggerDiv.innerText;

          // Use the modern Clipboard API
          navigator.clipboard.writeText(textToCopy)
            .then(() => {
              copyFeedback.classList.add('show');

              setTimeout(() => {
                copyFeedback.classList.remove('show');
                log('Logs successfully copied to clipboard!');
              }, 500);

            })
            .catch(err => {
              logToDiv('Failed to copy logs: ', err);
            });
        });
      }

      // cleanup on page unload
      window.addEventListener('unload', () => {
        logToDiv('Unloading page, stopping recording.');
        if (micStream) micStream.getTracks().forEach(t => t.stop());
      });

      window.addEventListener('visibilitychange', () => {
        const track = micStream?.getAudioTracks?.()[0];
        if (document.hidden) {
          logToDiv('Backgrounded', audioContext?.state, track?.readyState);
        } else {
          logToDiv('Foregrounded', audioContext?.state, track?.readyState);
          //audioContext?.resume();
        }
      });

      function log(...msg) {
        console.log(...msg);
      }

      /**
       * Logs a message to the loggerDiv as formatted text with line breaks.
       *
       * @param {...any} msg - The messages to be logged.
       */
      function logToDiv(...msg) {
        log(...msg);

        // 1. Format the log message
        const timestamp = new Date().toLocaleTimeString();
        const message = msg.map(m => (typeof m === 'string' ? m : JSON.stringify(m))).join(' ');

        const newLineContent = `[${timestamp}] ${message}`;

        // 2. Append the new content as text followed by a line break (<br>)
        // Using innerHTML allows the <br> tag to be interpreted.
        loggerDiv.innerHTML += newLineContent + '<br>\n';

        // 3. Auto-scroll to bottom
        logContent.scrollTop = logContent.scrollHeight;
      }


    })();
  </script>
</body>

</html>